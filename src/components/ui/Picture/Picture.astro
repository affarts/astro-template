---
import type { ImageMetadata, GetImageResult } from 'astro'
import { getImage, Image } from 'astro:assets'

const FOLDER_URL = '/src/assets/images'

type ImageFormat =
  | 'svg'
  | 'jpeg'
  | 'jpg'
  | 'png'
  | 'tiff'
  | 'webp'
  | 'gif'
  | 'avif'

export interface ImageSource {
  source: string
  media: string
  width: number
}

export interface Props {
  src: string
  srcset?: ImageSource[]
  // ширина изображения на десктопе
  width: number
  // ширина адаптивного изображения (для генерации правильного размера картинки) - не нужно для svg, т.к. svg не будет оптимизировано
  widths?: number[] | null
  alt?: string
  quality?: string | number
  densities?: number[]
  loading?: 'lazy' | 'eager'
  // дополнительные форматы
  formats?: ImageFormat[]
  // установить true, если в dev-режиме нужно сгенерировать все форматы изображений, которые будут использоваться в продакшене
  prodMode?: boolean
}

interface Srcset {
  media: string
  images: GetImageResult[]
}

const isProd = import.meta.env.PROD

const {
  src,
  srcset = null,
  width,
  widths = null,
  alt = '',
  quality = 80,
  densities = [2],
  loading = 'lazy',
  formats = ['webp'],
  prodMode = isProd
} = Astro.props

// выравниваем путь, убирая первый слеш, если он есть
const alignedSrc = src.startsWith('/') ? src.slice(1) : src
const type: ImageFormat = src.split('.').pop() as ImageFormat

if (type.length === 0) {
  throw new Error('The "src" property must include a file extension.')
}

const imagePath = `${FOLDER_URL}/${alignedSrc}`

const images = import.meta.glob<{ default: ImageMetadata }>(
  '/src/assets/images/**/*.{jpeg,jpg,png,gif,svg,webp,tiff,avif}'
)

// задает параметры для генерации картинок
const setImageParams = ({ srcImg, widthImg, format }) => {
  const densitiesSourceImg = widths !== null ? null : [1, ...densities]

  if (!images[srcImg]) {
    throw new Error(
      `File ${srcImg} not found. Please check if it exists in the specified directory or verify the correctness of the file path.`
    )
  }

  return {
    src: images[srcImg](),
    inferSize: true,
    format,
    type: `image/${format}`,
    width: widthImg,
    widths,
    densities: densitiesSourceImg,
    quality
  }
}

// генерирует картинки по заданным параметрам
const getFormatedImages = async (
  img: string,
  widthImg: number,
  formatsList: ImageFormat[]
): Promise<GetImageResult[]> => {
  let formatedImages = []

  for (const itemFormat of formatsList) {
    const imagePromise = getImage(
      setImageParams({ srcImg: img, widthImg, format: itemFormat })
    )
    formatedImages.push(imagePromise)
  }
  return await Promise.all(formatedImages)
}

let desktopImages: GetImageResult[] = []
let adaptiveImages: Srcset[] = []

desktopImages = await getFormatedImages(imagePath, width, formats)

if (srcset) {
  // const widthImg = widthAdaptive
  const formatImg = [...formats, type]
  const imgFormats = prodMode ? formatImg : [type]
  adaptiveImages = await Promise.all(
    srcset.map(async (source) => {
      const alignedSource = source.source.startsWith('/')
        ? source.source.slice(1)
        : source.source
      const imagePathSource = `${FOLDER_URL}/${alignedSource}`
      const imagesSet = await getFormatedImages(
        imagePathSource,
        source.width,
        imgFormats
      )
      return {
        media: source.media,
        images: imagesSet
      }
    })
  ).then((sets) => sets.flatMap((set) => set))
}
---

<picture>
  {
    srcset && (
      <>
        {adaptiveImages.map(({ media, images: sources }: Srcset) => {
          return sources.map((image: GetImageResult) => (
            <source
              srcset={image.srcSet.attribute}
              type={image.attributes.type}
              media={media}
            />
          ))
        })}
      </>
    )
  }
  {
    prodMode &&
      desktopImages &&
      desktopImages.map((image: any) => (
        <source srcset={image.srcSet.attribute} type={image.attributes.type} />
      ))
  }
  <Image
    src={images[imagePath]()}
    densities={densities}
    format={type}
    width={width}
    quality={quality}
    alt={alt}
    loading={loading}
  />
</picture>
